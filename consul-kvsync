#!/usr/bin/env perl

# consul-kvsync - keep a KV tree in sync with another
# Copyright (c) 2015 Robert Norris. MIT license.

use 5.014;
use warnings;
use strict;

use AnyEvent;
use AnyEvent::Consul 0.005;
use AnyEvent::Log;
use Sys::Syslog qw(openlog);
use Date::Format qw(time2str);

my $at_terminal = -t \*STDIN;

if (!$at_terminal || $ENV{CONSUL_KVSYNC_SYSLOG}) {
  openlog("consul-kvsync", "ndelay,pid", "local1");
  AnyEvent::Log::ctx->log_to_syslog("local1");
  AnyEvent::Log::ctx->fmt_cb(sub {
    my $str = $_[3];
    $str =~ s/\n(?=.)/\n+ /g;
    [$_[2], $str];
  });
}
else  {
  AnyEvent::Log::ctx->log_to_warn;
  AnyEvent::Log::ctx->fmt_cb(sub {
    sprintf "%s %s\n", time2str("%Y-%m-%dT%H:%M:%S", time), $_[3];
  });
}
my $log = AnyEvent::Log::logger("notice");

# args are shaped like: [kv-path@remote-dc]
# changes under the path on the remote are copied to the local (unnamed) dc on
# the same path

# path => source dc
my %dc_for_path;
for my $pathspec (@ARGV) {
  my ($path, $dc) = split '@', $pathspec;
  unless (defined $path && defined $dc) {
    die "E: invalid path: $pathspec\n";
  }
  if (exists $dc_for_path{$path}) {
    die "E: already declared path: $pathspec\n";
  }
  $dc_for_path{$path} = $dc;
}
my @paths = sort keys %dc_for_path;

unless (@paths) {
  if ($at_terminal) {
    say "usage: $0 [kv-path\@dc...]";
  }
  else {
    $log->("no paths configured, sleeping");
    while (1) { sleep 3600 }
  }
  exit 1;
}

my $cv = AnyEvent->condvar;
my $kvapi = AnyEvent::Consul->kv(timeout => 60);

for my $path (@paths) {
  my $dc = $dc_for_path{$path};
  $log->("$path\@$dc: starting watcher");
  setup_watcher($path, $dc, 0);
}

$cv->recv;

sub setup_watcher {
  my ($path, $dc, $index) = @_;

  # if a specific index is provided, then we should block until we move past
  # that index. index 0 is to get the initial state, and should just return
  my @extra;
  if ($index > 0) {
    @extra = (
      index => $index,
      wait => '30s',
    );
  }

  $kvapi->get_all(
    $path,
    dc => $dc,
    @extra,
    cb => sub { source_change_handler($path, $dc, $index, @_) },
    error_cb => sub { source_error_handler($path, $dc, @_) }
  );
}

sub error_handler {
  my ($path, $dc, $msg) = @_;

  $log->("E: $path\@$dc: $msg");

  my $sleep_guard; $sleep_guard = AnyEvent->timer(after => "1s", cb => sub {
    $log->("$path\@$dc: restarting watcher");
    setup_watcher($path, $dc, 0);
    undef $sleep_guard;
  });
}

sub change_handler {
  my ($path, $dc, $prev_index, $kv, $meta) = @_;

  my $index = $meta->index;

  if ($index > $prev_index) {
    my @changed = grep { $_->modify_index > $prev_index } @$kv;

    $log->(
      "$path\@$dc: $prev_index -> $index, "
      .scalar(@changed)." keys changed"
    );

    for my $change (@changed) {
      $kvapi->put(
        $change->key,
        $change->value,
        cb => sub {
          my ($success, $meta) = @_;
          $log->(
            "$path\@$dc: updated ".$change->key." to ".$change->value.", "
            .($success ? "succeeded" : "FAILED")
          );
      });
    }
  }

  setup_watcher($path, $dc, $index);
}

1;
